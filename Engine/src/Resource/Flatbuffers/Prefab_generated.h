// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PREFAB_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_PREFAB_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace flatbuffers {

struct Transform;

struct Node;
struct NodeBuilder;
struct NodeT;

struct Prefab;
struct PrefabBuilder;
struct PrefabT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Transform FLATBUFFERS_FINAL_CLASS {
 private:
  float position_[3];
  float rotation_[4];
  float scale_[3];

 public:
  Transform()
      : position_(),
        rotation_(),
        scale_() {
  }
  Transform(::flatbuffers::span<const float, 3> _position, ::flatbuffers::span<const float, 4> _rotation, ::flatbuffers::span<const float, 3> _scale) {
    ::flatbuffers::CastToArray(position_).CopyFromSpan(_position);
    ::flatbuffers::CastToArray(rotation_).CopyFromSpan(_rotation);
    ::flatbuffers::CastToArray(scale_).CopyFromSpan(_scale);
  }
  const ::flatbuffers::Array<float, 3> *position() const {
    return &::flatbuffers::CastToArray(position_);
  }
  const ::flatbuffers::Array<float, 4> *rotation() const {
    return &::flatbuffers::CastToArray(rotation_);
  }
  const ::flatbuffers::Array<float, 3> *scale() const {
    return &::flatbuffers::CastToArray(scale_);
  }
};
FLATBUFFERS_STRUCT_END(Transform, 40);

struct NodeT : public ::flatbuffers::NativeTable {
  typedef Node TableType;
  std::string name{};
  uint64_t mesh = 0;
  std::unique_ptr<flatbuffers::Transform> transform{};
  std::vector<std::unique_ptr<flatbuffers::NodeT>> children{};
  NodeT() = default;
  NodeT(const NodeT &o);
  NodeT(NodeT&&) FLATBUFFERS_NOEXCEPT = default;
  NodeT &operator=(NodeT o) FLATBUFFERS_NOEXCEPT;
};

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeT NativeTableType;
  typedef NodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_MESH = 6,
    VT_TRANSFORM = 8,
    VT_CHILDREN = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint64_t mesh() const {
    return GetField<uint64_t>(VT_MESH, 0);
  }
  const flatbuffers::Transform *transform() const {
    return GetStruct<const flatbuffers::Transform *>(VT_TRANSFORM);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::Node>> *children() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::Node>> *>(VT_CHILDREN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_MESH, 8) &&
           VerifyField<flatbuffers::Transform>(verifier, VT_TRANSFORM, 4) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
  NodeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NodeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Node> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  void add_mesh(uint64_t mesh) {
    fbb_.AddElement<uint64_t>(Node::VT_MESH, mesh, 0);
  }
  void add_transform(const flatbuffers::Transform *transform) {
    fbb_.AddStruct(Node::VT_TRANSFORM, transform);
  }
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::Node>>> children) {
    fbb_.AddOffset(Node::VT_CHILDREN, children);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint64_t mesh = 0,
    const flatbuffers::Transform *transform = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<flatbuffers::Node>>> children = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_mesh(mesh);
  builder_.add_children(children);
  builder_.add_transform(transform);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Node> CreateNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t mesh = 0,
    const flatbuffers::Transform *transform = nullptr,
    const std::vector<::flatbuffers::Offset<flatbuffers::Node>> *children = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto children__ = children ? _fbb.CreateVector<::flatbuffers::Offset<flatbuffers::Node>>(*children) : 0;
  return flatbuffers::CreateNode(
      _fbb,
      name__,
      mesh,
      transform,
      children__);
}

::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PrefabT : public ::flatbuffers::NativeTable {
  typedef Prefab TableType;
  std::unique_ptr<flatbuffers::NodeT> root{};
  PrefabT() = default;
  PrefabT(const PrefabT &o);
  PrefabT(PrefabT&&) FLATBUFFERS_NOEXCEPT = default;
  PrefabT &operator=(PrefabT o) FLATBUFFERS_NOEXCEPT;
};

struct Prefab FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PrefabT NativeTableType;
  typedef PrefabBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOT = 4
  };
  const flatbuffers::Node *root() const {
    return GetPointer<const flatbuffers::Node *>(VT_ROOT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOT) &&
           verifier.VerifyTable(root()) &&
           verifier.EndTable();
  }
  PrefabT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PrefabT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Prefab> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PrefabT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PrefabBuilder {
  typedef Prefab Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_root(::flatbuffers::Offset<flatbuffers::Node> root) {
    fbb_.AddOffset(Prefab::VT_ROOT, root);
  }
  explicit PrefabBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Prefab> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Prefab>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Prefab> CreatePrefab(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<flatbuffers::Node> root = 0) {
  PrefabBuilder builder_(_fbb);
  builder_.add_root(root);
  return builder_.Finish();
}

::flatbuffers::Offset<Prefab> CreatePrefab(::flatbuffers::FlatBufferBuilder &_fbb, const PrefabT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline NodeT::NodeT(const NodeT &o)
      : name(o.name),
        mesh(o.mesh),
        transform((o.transform) ? new flatbuffers::Transform(*o.transform) : nullptr) {
  children.reserve(o.children.size());
  for (const auto &children_ : o.children) { children.emplace_back((children_) ? new flatbuffers::NodeT(*children_) : nullptr); }
}

inline NodeT &NodeT::operator=(NodeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(mesh, o.mesh);
  std::swap(transform, o.transform);
  std::swap(children, o.children);
  return *this;
}

inline NodeT *Node::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NodeT>(new NodeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Node::UnPackTo(NodeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = mesh(); _o->mesh = _e; }
  { auto _e = transform(); if (_e) _o->transform = std::unique_ptr<flatbuffers::Transform>(new flatbuffers::Transform(*_e)); }
  { auto _e = children(); if (_e) { _o->children.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->children[_i]) { _e->Get(_i)->UnPackTo(_o->children[_i].get(), _resolver); } else { _o->children[_i] = std::unique_ptr<flatbuffers::NodeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->children.resize(0); } }
}

inline ::flatbuffers::Offset<Node> Node::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NodeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _mesh = _o->mesh;
  auto _transform = _o->transform ? _o->transform.get() : nullptr;
  auto _children = _o->children.size() ? _fbb.CreateVector<::flatbuffers::Offset<flatbuffers::Node>> (_o->children.size(), [](size_t i, _VectorArgs *__va) { return CreateNode(*__va->__fbb, __va->__o->children[i].get(), __va->__rehasher); }, &_va ) : 0;
  return flatbuffers::CreateNode(
      _fbb,
      _name,
      _mesh,
      _transform,
      _children);
}

inline PrefabT::PrefabT(const PrefabT &o)
      : root((o.root) ? new flatbuffers::NodeT(*o.root) : nullptr) {
}

inline PrefabT &PrefabT::operator=(PrefabT o) FLATBUFFERS_NOEXCEPT {
  std::swap(root, o.root);
  return *this;
}

inline PrefabT *Prefab::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PrefabT>(new PrefabT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Prefab::UnPackTo(PrefabT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = root(); if (_e) { if(_o->root) { _e->UnPackTo(_o->root.get(), _resolver); } else { _o->root = std::unique_ptr<flatbuffers::NodeT>(_e->UnPack(_resolver)); } } else if (_o->root) { _o->root.reset(); } }
}

inline ::flatbuffers::Offset<Prefab> Prefab::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PrefabT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePrefab(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Prefab> CreatePrefab(::flatbuffers::FlatBufferBuilder &_fbb, const PrefabT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PrefabT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _root = _o->root ? CreateNode(_fbb, _o->root.get(), _rehasher) : 0;
  return flatbuffers::CreatePrefab(
      _fbb,
      _root);
}

inline const flatbuffers::Prefab *GetPrefab(const void *buf) {
  return ::flatbuffers::GetRoot<flatbuffers::Prefab>(buf);
}

inline const flatbuffers::Prefab *GetSizePrefixedPrefab(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<flatbuffers::Prefab>(buf);
}

inline bool VerifyPrefabBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flatbuffers::Prefab>(nullptr);
}

inline bool VerifySizePrefixedPrefabBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flatbuffers::Prefab>(nullptr);
}

inline void FinishPrefabBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<flatbuffers::Prefab> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPrefabBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<flatbuffers::Prefab> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<flatbuffers::PrefabT> UnPackPrefab(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<flatbuffers::PrefabT>(GetPrefab(buf)->UnPack(res));
}

inline std::unique_ptr<flatbuffers::PrefabT> UnPackSizePrefixedPrefab(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<flatbuffers::PrefabT>(GetSizePrefixedPrefab(buf)->UnPack(res));
}

}  // namespace flatbuffers

#endif  // FLATBUFFERS_GENERATED_PREFAB_FLATBUFFERS_H_
